// Code generated by entc, DO NOT EDIT.

package miner

import (
	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/frrist/specs-actors-model/ent/predicate"
)

// ID filters vertices based on their identifier.
func ID(id int) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// StateRoot applies equality check predicate on the "state_root" field. It's identical to StateRootEQ.
func StateRoot(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStateRoot), v))
	})
}

// MinerID applies equality check predicate on the "miner_id" field. It's identical to MinerIDEQ.
func MinerID(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMinerID), v))
	})
}

// OwnerAddr applies equality check predicate on the "owner_addr" field. It's identical to OwnerAddrEQ.
func OwnerAddr(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOwnerAddr), v))
	})
}

// WorkerAddr applies equality check predicate on the "worker_addr" field. It's identical to WorkerAddrEQ.
func WorkerAddr(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWorkerAddr), v))
	})
}

// PeerID applies equality check predicate on the "peer_id" field. It's identical to PeerIDEQ.
func PeerID(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPeerID), v))
	})
}

// SectorSize applies equality check predicate on the "sector_size" field. It's identical to SectorSizeEQ.
func SectorSize(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSectorSize), v))
	})
}

// StateRootEQ applies the EQ predicate on the "state_root" field.
func StateRootEQ(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStateRoot), v))
	})
}

// StateRootNEQ applies the NEQ predicate on the "state_root" field.
func StateRootNEQ(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStateRoot), v))
	})
}

// StateRootIn applies the In predicate on the "state_root" field.
func StateRootIn(vs ...string) predicate.Miner {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Miner(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStateRoot), v...))
	})
}

// StateRootNotIn applies the NotIn predicate on the "state_root" field.
func StateRootNotIn(vs ...string) predicate.Miner {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Miner(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStateRoot), v...))
	})
}

// StateRootGT applies the GT predicate on the "state_root" field.
func StateRootGT(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldStateRoot), v))
	})
}

// StateRootGTE applies the GTE predicate on the "state_root" field.
func StateRootGTE(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldStateRoot), v))
	})
}

// StateRootLT applies the LT predicate on the "state_root" field.
func StateRootLT(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldStateRoot), v))
	})
}

// StateRootLTE applies the LTE predicate on the "state_root" field.
func StateRootLTE(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldStateRoot), v))
	})
}

// StateRootContains applies the Contains predicate on the "state_root" field.
func StateRootContains(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldStateRoot), v))
	})
}

// StateRootHasPrefix applies the HasPrefix predicate on the "state_root" field.
func StateRootHasPrefix(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldStateRoot), v))
	})
}

// StateRootHasSuffix applies the HasSuffix predicate on the "state_root" field.
func StateRootHasSuffix(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldStateRoot), v))
	})
}

// StateRootEqualFold applies the EqualFold predicate on the "state_root" field.
func StateRootEqualFold(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldStateRoot), v))
	})
}

// StateRootContainsFold applies the ContainsFold predicate on the "state_root" field.
func StateRootContainsFold(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldStateRoot), v))
	})
}

// MinerIDEQ applies the EQ predicate on the "miner_id" field.
func MinerIDEQ(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMinerID), v))
	})
}

// MinerIDNEQ applies the NEQ predicate on the "miner_id" field.
func MinerIDNEQ(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMinerID), v))
	})
}

// MinerIDIn applies the In predicate on the "miner_id" field.
func MinerIDIn(vs ...string) predicate.Miner {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Miner(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMinerID), v...))
	})
}

// MinerIDNotIn applies the NotIn predicate on the "miner_id" field.
func MinerIDNotIn(vs ...string) predicate.Miner {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Miner(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMinerID), v...))
	})
}

// MinerIDGT applies the GT predicate on the "miner_id" field.
func MinerIDGT(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMinerID), v))
	})
}

// MinerIDGTE applies the GTE predicate on the "miner_id" field.
func MinerIDGTE(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMinerID), v))
	})
}

// MinerIDLT applies the LT predicate on the "miner_id" field.
func MinerIDLT(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMinerID), v))
	})
}

// MinerIDLTE applies the LTE predicate on the "miner_id" field.
func MinerIDLTE(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMinerID), v))
	})
}

// MinerIDContains applies the Contains predicate on the "miner_id" field.
func MinerIDContains(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldMinerID), v))
	})
}

// MinerIDHasPrefix applies the HasPrefix predicate on the "miner_id" field.
func MinerIDHasPrefix(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldMinerID), v))
	})
}

// MinerIDHasSuffix applies the HasSuffix predicate on the "miner_id" field.
func MinerIDHasSuffix(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldMinerID), v))
	})
}

// MinerIDEqualFold applies the EqualFold predicate on the "miner_id" field.
func MinerIDEqualFold(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldMinerID), v))
	})
}

// MinerIDContainsFold applies the ContainsFold predicate on the "miner_id" field.
func MinerIDContainsFold(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldMinerID), v))
	})
}

// OwnerAddrEQ applies the EQ predicate on the "owner_addr" field.
func OwnerAddrEQ(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOwnerAddr), v))
	})
}

// OwnerAddrNEQ applies the NEQ predicate on the "owner_addr" field.
func OwnerAddrNEQ(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldOwnerAddr), v))
	})
}

// OwnerAddrIn applies the In predicate on the "owner_addr" field.
func OwnerAddrIn(vs ...string) predicate.Miner {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Miner(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldOwnerAddr), v...))
	})
}

// OwnerAddrNotIn applies the NotIn predicate on the "owner_addr" field.
func OwnerAddrNotIn(vs ...string) predicate.Miner {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Miner(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldOwnerAddr), v...))
	})
}

// OwnerAddrGT applies the GT predicate on the "owner_addr" field.
func OwnerAddrGT(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldOwnerAddr), v))
	})
}

// OwnerAddrGTE applies the GTE predicate on the "owner_addr" field.
func OwnerAddrGTE(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldOwnerAddr), v))
	})
}

// OwnerAddrLT applies the LT predicate on the "owner_addr" field.
func OwnerAddrLT(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldOwnerAddr), v))
	})
}

// OwnerAddrLTE applies the LTE predicate on the "owner_addr" field.
func OwnerAddrLTE(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldOwnerAddr), v))
	})
}

// OwnerAddrContains applies the Contains predicate on the "owner_addr" field.
func OwnerAddrContains(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldOwnerAddr), v))
	})
}

// OwnerAddrHasPrefix applies the HasPrefix predicate on the "owner_addr" field.
func OwnerAddrHasPrefix(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldOwnerAddr), v))
	})
}

// OwnerAddrHasSuffix applies the HasSuffix predicate on the "owner_addr" field.
func OwnerAddrHasSuffix(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldOwnerAddr), v))
	})
}

// OwnerAddrEqualFold applies the EqualFold predicate on the "owner_addr" field.
func OwnerAddrEqualFold(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldOwnerAddr), v))
	})
}

// OwnerAddrContainsFold applies the ContainsFold predicate on the "owner_addr" field.
func OwnerAddrContainsFold(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldOwnerAddr), v))
	})
}

// WorkerAddrEQ applies the EQ predicate on the "worker_addr" field.
func WorkerAddrEQ(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWorkerAddr), v))
	})
}

// WorkerAddrNEQ applies the NEQ predicate on the "worker_addr" field.
func WorkerAddrNEQ(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWorkerAddr), v))
	})
}

// WorkerAddrIn applies the In predicate on the "worker_addr" field.
func WorkerAddrIn(vs ...string) predicate.Miner {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Miner(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldWorkerAddr), v...))
	})
}

// WorkerAddrNotIn applies the NotIn predicate on the "worker_addr" field.
func WorkerAddrNotIn(vs ...string) predicate.Miner {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Miner(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldWorkerAddr), v...))
	})
}

// WorkerAddrGT applies the GT predicate on the "worker_addr" field.
func WorkerAddrGT(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldWorkerAddr), v))
	})
}

// WorkerAddrGTE applies the GTE predicate on the "worker_addr" field.
func WorkerAddrGTE(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldWorkerAddr), v))
	})
}

// WorkerAddrLT applies the LT predicate on the "worker_addr" field.
func WorkerAddrLT(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldWorkerAddr), v))
	})
}

// WorkerAddrLTE applies the LTE predicate on the "worker_addr" field.
func WorkerAddrLTE(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldWorkerAddr), v))
	})
}

// WorkerAddrContains applies the Contains predicate on the "worker_addr" field.
func WorkerAddrContains(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldWorkerAddr), v))
	})
}

// WorkerAddrHasPrefix applies the HasPrefix predicate on the "worker_addr" field.
func WorkerAddrHasPrefix(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldWorkerAddr), v))
	})
}

// WorkerAddrHasSuffix applies the HasSuffix predicate on the "worker_addr" field.
func WorkerAddrHasSuffix(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldWorkerAddr), v))
	})
}

// WorkerAddrEqualFold applies the EqualFold predicate on the "worker_addr" field.
func WorkerAddrEqualFold(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldWorkerAddr), v))
	})
}

// WorkerAddrContainsFold applies the ContainsFold predicate on the "worker_addr" field.
func WorkerAddrContainsFold(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldWorkerAddr), v))
	})
}

// PeerIDEQ applies the EQ predicate on the "peer_id" field.
func PeerIDEQ(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPeerID), v))
	})
}

// PeerIDNEQ applies the NEQ predicate on the "peer_id" field.
func PeerIDNEQ(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPeerID), v))
	})
}

// PeerIDIn applies the In predicate on the "peer_id" field.
func PeerIDIn(vs ...string) predicate.Miner {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Miner(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPeerID), v...))
	})
}

// PeerIDNotIn applies the NotIn predicate on the "peer_id" field.
func PeerIDNotIn(vs ...string) predicate.Miner {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Miner(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPeerID), v...))
	})
}

// PeerIDGT applies the GT predicate on the "peer_id" field.
func PeerIDGT(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPeerID), v))
	})
}

// PeerIDGTE applies the GTE predicate on the "peer_id" field.
func PeerIDGTE(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPeerID), v))
	})
}

// PeerIDLT applies the LT predicate on the "peer_id" field.
func PeerIDLT(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPeerID), v))
	})
}

// PeerIDLTE applies the LTE predicate on the "peer_id" field.
func PeerIDLTE(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPeerID), v))
	})
}

// PeerIDContains applies the Contains predicate on the "peer_id" field.
func PeerIDContains(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPeerID), v))
	})
}

// PeerIDHasPrefix applies the HasPrefix predicate on the "peer_id" field.
func PeerIDHasPrefix(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPeerID), v))
	})
}

// PeerIDHasSuffix applies the HasSuffix predicate on the "peer_id" field.
func PeerIDHasSuffix(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPeerID), v))
	})
}

// PeerIDEqualFold applies the EqualFold predicate on the "peer_id" field.
func PeerIDEqualFold(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPeerID), v))
	})
}

// PeerIDContainsFold applies the ContainsFold predicate on the "peer_id" field.
func PeerIDContainsFold(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPeerID), v))
	})
}

// SectorSizeEQ applies the EQ predicate on the "sector_size" field.
func SectorSizeEQ(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSectorSize), v))
	})
}

// SectorSizeNEQ applies the NEQ predicate on the "sector_size" field.
func SectorSizeNEQ(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSectorSize), v))
	})
}

// SectorSizeIn applies the In predicate on the "sector_size" field.
func SectorSizeIn(vs ...string) predicate.Miner {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Miner(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSectorSize), v...))
	})
}

// SectorSizeNotIn applies the NotIn predicate on the "sector_size" field.
func SectorSizeNotIn(vs ...string) predicate.Miner {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Miner(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSectorSize), v...))
	})
}

// SectorSizeGT applies the GT predicate on the "sector_size" field.
func SectorSizeGT(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSectorSize), v))
	})
}

// SectorSizeGTE applies the GTE predicate on the "sector_size" field.
func SectorSizeGTE(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSectorSize), v))
	})
}

// SectorSizeLT applies the LT predicate on the "sector_size" field.
func SectorSizeLT(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSectorSize), v))
	})
}

// SectorSizeLTE applies the LTE predicate on the "sector_size" field.
func SectorSizeLTE(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSectorSize), v))
	})
}

// SectorSizeContains applies the Contains predicate on the "sector_size" field.
func SectorSizeContains(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSectorSize), v))
	})
}

// SectorSizeHasPrefix applies the HasPrefix predicate on the "sector_size" field.
func SectorSizeHasPrefix(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSectorSize), v))
	})
}

// SectorSizeHasSuffix applies the HasSuffix predicate on the "sector_size" field.
func SectorSizeHasSuffix(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSectorSize), v))
	})
}

// SectorSizeEqualFold applies the EqualFold predicate on the "sector_size" field.
func SectorSizeEqualFold(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSectorSize), v))
	})
}

// SectorSizeContainsFold applies the ContainsFold predicate on the "sector_size" field.
func SectorSizeContainsFold(v string) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSectorSize), v))
	})
}

// And groups list of predicates with the AND operator between them.
func And(predicates ...predicate.Miner) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups list of predicates with the OR operator between them.
func Or(predicates ...predicate.Miner) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Miner) predicate.Miner {
	return predicate.Miner(func(s *sql.Selector) {
		p(s.Not())
	})
}
